import importlib
import pathlib
import shutil
from urllib.parse import urlparse

import invoke
from bs4 import BeautifulSoup


def _exit_with_error_if_docs_dependencies_are_not_installed():
    """Check and report which dependencies are not installed."""

    module_dependencies = ("sphinx", "myst_parser", "pydata_sphinx_theme")
    modules_not_installed = []

    for module_name in module_dependencies:
        try:
            importlib.import_module(module_name)
        except ImportError:
            modules_not_installed.append(module_name)

    if modules_not_installed:
        raise invoke.Exit(
            f"Please make sure to install missing docs dependencies: {', '.join(modules_not_installed)} by running pip install -r docs/sphinx_api_docs_source/requirements-dev-api-docs.txt",
            code=1,
        )


def _remove_existing_sphinx_api_docs(ctx: invoke.context.Context):
    """Remove existing sphinx api docs."""
    cmds = ["make clean"]
    ctx.run(" ".join(cmds), echo=True, pty=True)


def _build_html_api_docs_in_temp_folder(ctx: invoke.context.Context):
    """Build html api documentation in temporary folder."""

    cmds = ["sphinx-build -M html ./ ../../temp_docs_build_dir/sphinx_api_docs"]
    ctx.run(" ".join(cmds), echo=True, pty=True)


def _remove_existing_api_docs(repo_root: pathlib.Path):
    """Remove the existing api docs."""
    api_path = repo_root / pathlib.Path("docs/reference/api")
    if api_path.is_dir():
        shutil.rmtree(api_path)
    pathlib.Path(api_path).mkdir(parents=True, exist_ok=True)


def _process_and_create_docusaurus_mdx_files(
    repo_root: pathlib.Path, temp_docs_build_dir: pathlib.Path
):
    """Create API docs as mdx files to serve from docusaurus from content between <section> tags in the sphinx generated docs."""
    # Process and create mdx files
    # First get file paths
    sphinx_api_docs_build_dir = temp_docs_build_dir / "sphinx_api_docs"

    static_html_file_path = pathlib.Path(sphinx_api_docs_build_dir) / "html"
    paths = static_html_file_path.glob("**/*.html")
    files = [
        p
        for p in paths
        if p.is_file()
        and p.name not in ("genindex.html", "search.html", "index.html")
        and "_static" not in str(p)
    ]

    # Read the generated html and process the content for conversion to mdx
    # Write out to .mdx file using the relative file directory structure
    for html_file in files:
        print("Processing:", html_file.absolute())
        with open(html_file, "r") as f:
            soup = BeautifulSoup(f.read(), "html.parser")

            # Retrieve and remove the title (it will also be autogenerated by docusaurus)
            title = soup.find("h1").extract()
            title_str = title.get_text(strip=True)
            title_str = title_str.replace("#", "")

            # Add class="sphinx-api-doc" to section tag to reference in css
            doc = soup.find("section")
            doc["class"] = "sphinx-api-doc"

            # Process documentation links
            external_refs = doc.find_all(class_="reference external")
            for external_ref in external_refs:
                url = external_ref.string
                url_parts = urlparse(url)
                url_path = url_parts.path.strip("/").split("/")
                url_text = url_path[-1]

                formatted_text = url_text.replace("_", " ").title()

                external_ref.string = formatted_text

            doc_str = str(doc)

            # Add front matter
            doc_front_matter = (
                "---\n"
                f"title: {title_str}\n"
                f"sidebar_label: {title_str}\n"
                "---\n"
                "\n"
            )
            doc_str = doc_front_matter + doc_str

            # Write out mdx files
            output_path = (
                repo_root
                / pathlib.Path("docs/reference/api")
                / html_file.relative_to(static_html_file_path).with_suffix(".mdx")
            )
            output_path.parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, "w") as fout:
                fout.write(doc_str)
